--랭크함수

--정규화되어 있는 테이블
CREATE TABLE SALLARY
(
    IDX NUMBER(5) NOT NULL PRIMARY KEY,
    PART VARCHAR2(30) NOT NULL,
    ENAME VARCHAR2(30) NOT NULL,
    PRICE NUMBER(10) NOT NULL
);

INSERT INTO SALLARY VALUES(1, '인사부', '홍길동', 5000000);
INSERT INTO SALLARY VALUES(2, '인사부', '전우치', 4000000);
INSERT INTO SALLARY VALUES(3, '인사부', '김갑순', 3000000);
INSERT INTO SALLARY VALUES(4, '총무부', '김갑돌', 7000000);
INSERT INTO SALLARY VALUES(5, '총무부', '박우수', 2000000);
INSERT INTO SALLARY VALUES(6, '총무부', '김돌쇠', 3500000);
INSERT INTO SALLARY VALUES(7, '생산부', '김동욱', 6400000);
INSERT INTO SALLARY VALUES(8, '생산부', '이건도', 5500000);
INSERT INTO SALLARY VALUES(9, '구매부', '김수인', 1500000);
INSERT INTO SALLARY VALUES(10, '구매부', '김소희', 4500000);

UPDATE SALLARY SET PRICE = 5500000
WHERE IDX = 10
;

SELECT * FROM SALLARY;

--ROLLBACK;
--COMMIT;

--ROW_NUMBER() > 오라클에서만 사용

SELECT IDX, PART, ENAME, PRICE, 
    ROW_NUMBER() OVER(ORDER BY ENAME ASC) AS ROW_NUM --독립적으로 ORDER를 준 필드에 숫자를 주는것 만약 값이 같으면 먼저 쌓인순서로 보여줌
    ,RANK() OVER(ORDER BY PRICE ASC) AS ROW_NUM -- ROW_NUMBER와 비슷하지만 같은값에 같은 숫자를 준다 
    ,DENSE_RANK() OVER(ORDER BY PRICE ASC) AS DENSERNK -- 같은값에 같은 숫자를 주는데 그만큼 마지막값이 준다
FROM SALLARY
ORDER BY IDX ASC
;

SELECT *
FROM SALLARY
ORDER BY PART ASC, ENAME ASC --정렬내의 정렬
;

--각 부서별로 월급 RANK를 만들자
SELECT PART, SUM(PRICE), AVG(PRICE)
    ,RANK() OVER(ORDER BY SUM(PRICE) DESC) AS RNK
    ,RANK() OVER(ORDER BY AVG(PRICE) DESC) AS AVG
FROM SALLARY
GROUP BY PART
;

--ROUND 반올림,자릿수
SELECT PART, ENAME, PRICE
    ,ROUND(AVG(PRICE) OVER(PARTITION BY PART),2) AS PART_AVG
    ,RANK() OVER(ORDER BY PRICE DESC) AS RNK
FROM SALLARY
;

--전체평균 월급과 10명의 각각의 월급과의 차이를 보여주세요

SELECT IDX, PART, ENAME, PRICE, PRICE - (SELECT AVG(PRICE)FROM SALLARY) AS AVGPRICE
FROM SALLARY
GROUP BY IDX, PART, ENAME, PRICE
;

SELECT ENAME, PRICE, AVER, PRICE - AVER
FROM SALLARY,(SELECT AVG(PRICE) AS AVER
FROM SALLARY)
;


--각 부서별 평균월급의 순위를 구해주세요

SELECT PART, AVG(PRICE), RANK() OVER(ORDER BY AVG(PRICE) DESC) 
FROM SALLARY
GROUP BY PART
;

SELECT PART, RANK() OVER(ORDER BY AVER DESC) AS RNK
FROM
(
    SELECT PART, AVG(PRICE) AS AVER
    FROM SALLARY
    GROUP BY PART
)
;
--평균월급이 3위인 부서의 월급보다 많은 월급을 받고있는 사원들을 보여주세요

SELECT PART, ENAME, PRICE
FROM
(
    SELECT AVGPRICE FROM
        (
            SELECT PART, AVG(PRICE) AS AVGPRICE, RANK() OVER(ORDER BY AVG(PRICE) DESC) AS RNK_NUM
            FROM SALLARY
            GROUP BY PART
        )
    WHERE RNK_NUM = 3
)T1, SALLARY
WHERE PRICE > T1.AVGPRICE
ORDER BY PRICE DESC
;

SELECT * FROM SALLARY
WHERE PRICE >
(
    SELECT AVGPRICE FROM
            (
                SELECT PART, AVG(PRICE) AS AVGPRICE, RANK() OVER(ORDER BY AVG(PRICE) DESC) AS RNK_NUM
                FROM SALLARY
                GROUP BY PART
            )
        WHERE RNK_NUM = 3
)
;

--1. DATE > 진짜로 많이쓴다.
--2. RANK,  DENSE_RANK, ROW_NUMBER ORDER BY PARTITION BY
--3. NVL, DECODE, CASE WHEN THEN

--TRANSACTION

--GROUP BY 활용도

SELECT ENAME, COUNT(*) FROM SALLARY
GROUP BY ENAME
HAVING COUNT(*) > 1
;--이 경우 조인을 쓰면 위험하다

INSERT INTO SALLARY VALUES(11, '구매부', '홍길동', 4000000); 
--COMMIT;